File: cmd/client/main.go
----------------------------------------
package main

import (
	"flag"
	"log"

	"github.com/faiface/pixel/pixelgl"
	"github.com/suifei/godesk/internal/client"
)

func run() {
	serverIP := flag.String("server", "localhost", "Server IP address")
	serverPort := flag.String("port", "3388", "Server port")
	flag.Parse()

	serverAddr := *serverIP + ":" + *serverPort
	log.Printf("Connecting to server at %s", serverAddr)

	clientHandler, err := client.NewClientHandler(serverAddr)
	if err != nil {
		log.Fatalf("Failed to create client handler: %v", err)
	}

	log.Printf("Connected to server at %s", serverAddr)

	clientHandler.Handle()
}

func main() {
	pixelgl.Run(run)
}


========================================


File: cmd/relay/main.go
----------------------------------------
package main

func main() {
}

========================================


File: cmd/server/main.go
----------------------------------------
package main

import (
	"flag"
	"fmt"
	"log"
	"net"
	"os"
	"path/filepath"
	"time"

	"bytes"
	"image/png"

	"github.com/suifei/godesk/internal/server"
	"github.com/suifei/godesk/pkg/network"
)

func main() {
	// 定义命令行参数
	port := flag.String("port", "3388", "Port to listen on")
	flag.Parse()

	// 测试屏幕捕获
	testScreenCapture()

	// 构建监听地址
	addr := fmt.Sprintf("0.0.0.0:%s", *port)
	listener, err := net.Listen("tcp", addr)
	if err != nil {
		log.Fatalf("Failed to start server: %v", err)
	}
	defer listener.Close()

	log.Printf("Server listening on %s", addr)

	for {
		log.Println("Waiting for new connection...")
		conn, err := listener.Accept()
		if err != nil {
			log.Printf("Failed to accept connection: %v", err)
			continue
		}

		log.Printf("New connection accepted from %s", conn.RemoteAddr())
		tcpConn := network.NewTCPConnection(conn)
		go handleClient(tcpConn)
	}
}

func handleClient(conn *network.TCPConnection) {
	defer conn.Close()

	remoteAddr := conn.RemoteAddr().String()
	log.Printf("Handling client from %s", remoteAddr)

	clientHandler := server.NewClientHandler(conn)
	log.Printf("Starting to handle client from %s", remoteAddr)

	// 添加一个 done channel 来通知主 goroutine 何时完成
	done := make(chan struct{})
	go func() {
		clientHandler.Handle()
		close(done)
	}()

	// 等待处理完成或超时
	select {
	case <-done:
		log.Printf("Finished handling client from %s", remoteAddr)
	case <-time.After(5 * time.Minute):
		log.Printf("Client handling timed out for %s", remoteAddr)
	}
}
func testScreenCapture() {
	capturer := server.NewCapturer(100 * time.Millisecond)
	update, err := capturer.CaptureScreen()
	if err != nil {
		log.Fatalf("Failed to capture screen: %v", err)
	}

	log.Printf("Test capture successful: %dx%d, %d bytes",
		update.Width, update.Height, len(update.ImageData))

	// 保存捕获的图像
	img, err := png.Decode(bytes.NewReader(update.ImageData))
	if err != nil {
		log.Fatalf("Failed to decode captured image: %v", err)
	}

	outputDir := "test_captures"
	if err := os.MkdirAll(outputDir, os.ModePerm); err != nil {
		log.Fatalf("Failed to create output directory: %v", err)
	}

	outputPath := filepath.Join(outputDir, "test_capture.png")
	f, err := os.Create(outputPath)
	if err != nil {
		log.Fatalf("Failed to create output file: %v", err)
	}
	defer f.Close()

	if err := png.Encode(f, img); err != nil {
		log.Fatalf("Failed to save captured image: %v", err)
	}

	log.Printf("Test capture saved to: %s", outputPath)
}


========================================


File: go.mod
----------------------------------------
module github.com/suifei/godesk

go 1.22.3

require (
	github.com/faiface/pixel v0.10.0
	github.com/kbinani/screenshot v0.0.0-20230812210009-b87d31814237
	google.golang.org/protobuf v1.32.0
)

require (
	github.com/faiface/glhf v0.0.0-20181018222622-82a6317ac380 // indirect
	github.com/faiface/mainthread v0.0.0-20171120011319-8b78f0a41ae3 // indirect
	github.com/gen2brain/shm v0.0.0-20230802011745-f2460f5984f7 // indirect
	github.com/go-gl/gl v0.0.0-20190320180904-bf2b1f2f34d7 // indirect
	github.com/go-gl/glfw/v3.3/glfw v0.0.0-20191125211704-12ad95a8df72 // indirect
	github.com/go-gl/mathgl v0.0.0-20190416160123-c4601bc793c7 // indirect
	github.com/jezek/xgb v1.1.0 // indirect
	github.com/lxn/win v0.0.0-20210218163916-a377121e959e // indirect
	github.com/pkg/errors v0.8.1 // indirect
	github.com/stretchr/testify v1.9.0 // indirect
	golang.org/x/image v0.15.0 // indirect
	golang.org/x/sys v0.16.0 // indirect
	golang.org/x/xerrors v0.0.0-20220907171357-04be3eba64a2 // indirect
)


========================================


File: internal/auth/session.go
----------------------------------------
package auth

import (
    "time"
)

type Session struct {
    Token string
    UserID string
    ExpiresAt time.Time
}

func NewSession(userID string, duration time.Duration) *Session {
    return &Session{
        Token: generateToken(),
        UserID: userID,
        ExpiresAt: time.Now().Add(duration),
    }
}

func (s *Session) IsValid() bool {
    return time.Now().Before(s.ExpiresAt)
}

func generateToken() string {
    // 实现一个安全的令牌生成方法
    // 这里仅作为示例
    return "example-token"
}

========================================


File: internal/auth/user.go
----------------------------------------
package auth

import (
    "crypto/sha256"
    "encoding/hex"
)

type User struct {
    Username string
    PasswordHash string
}

func NewUser(username, password string) *User {
    return &User{
        Username: username,
        PasswordHash: hashPassword(password),
    }
}

func (u *User) Authenticate(password string) bool {
    return u.PasswordHash == hashPassword(password)
}

func hashPassword(password string) string {
    hash := sha256.Sum256([]byte(password))
    return hex.EncodeToString(hash[:])
}

========================================


File: internal/client/display.go
----------------------------------------
package client

import (
	"bytes"
	"image/png"
	"log"
	"sync"

	"github.com/faiface/pixel"
	"github.com/faiface/pixel/pixelgl"
	"github.com/suifei/godesk/internal/protocol"
)

type Display struct {
	Window     *pixelgl.Window
	sprite     *pixel.Sprite
	spriteRect pixel.Rect
	mutex      sync.Mutex
}

func NewDisplay() *Display {
	cfg := pixelgl.WindowConfig{
		Title:     "GoDesk Client",
		Bounds:    pixel.R(0, 0, 800, 600),
		VSync:     true,
		Resizable: true,
	}
	win, err := pixelgl.NewWindow(cfg)
	if err != nil {
		log.Fatalf("Failed to create window: %v", err)
	}
	return &Display{Window: win}
}

func (d *Display) UpdateScreen(update *protocol.ScreenUpdate) {
	d.mutex.Lock()
	defer d.mutex.Unlock()

	if update == nil || len(update.ImageData) == 0 {
		log.Println("Received empty screen update")
		return
	}

	img, err := png.Decode(bytes.NewReader(update.ImageData))
	if err != nil {
		log.Printf("Error decoding screen update: %v", err)
		return
	}

	pic := pixel.PictureDataFromImage(img)
	d.sprite = pixel.NewSprite(pic, pic.Bounds())
	d.spriteRect = pic.Bounds()
	log.Printf("Updated sprite with new image: %dx%d", d.spriteRect.W(), d.spriteRect.H())
}

func (d *Display) Update() {
	d.mutex.Lock()
	defer d.mutex.Unlock()

	d.Window.Clear(pixel.RGB(0, 0, 0))
	if d.sprite != nil {
		// 计算缩放比例
		scale := min(
			d.Window.Bounds().W()/d.spriteRect.W(),
			d.Window.Bounds().H()/d.spriteRect.H(),
		)

		// 计算绘制位置，使图像居中
		pos := d.Window.Bounds().Center()

		// 绘制精灵
		d.sprite.Draw(d.Window, pixel.IM.Scaled(pixel.ZV, scale).Moved(pos))
		log.Println("Drew sprite to window")
	} else {
		log.Println("No sprite to draw")
	}
	d.Window.Update()
}

func (d *Display) ShouldClose() bool {
	return d.Window.Closed()
}

func min(a, b float64) float64 {
	if a < b {
		return a
	}
	return b
}


========================================


File: internal/client/filetransfer.go
----------------------------------------
package client

import (
    "io"
    "os"
    "path/filepath"
)

func SendFile(conn io.Writer, filePath string) error {
    file, err := os.Open(filePath)
    if err != nil {
        return err
    }
    defer file.Close()

    _, err = io.Copy(conn, file)
    return err
}

func ReceiveFile(conn io.Reader, filePath string) error {
    os.MkdirAll(filepath.Dir(filePath), os.ModePerm)
    
    file, err := os.Create(filePath)
    if err != nil {
        return err
    }
    defer file.Close()

    _, err = io.Copy(file, conn)
    return err
}

========================================


File: internal/client/handler.go
----------------------------------------
package client

import (
	"log"
	"net"
	"time"

	"github.com/suifei/godesk/internal/protocol"
	"github.com/suifei/godesk/pkg/network"
)

type ClientHandler struct {
	conn    *network.TCPConnection
	display *Display
	input   *InputHandler
	running bool
}

func NewClientHandler(serverAddr string) (*ClientHandler, error) {
	log.Printf("Attempting to connect to %s", serverAddr)
	conn, err := net.DialTimeout("tcp", serverAddr, 5*time.Second)
	if err != nil {
		log.Printf("Failed to connect to server: %v", err)
		return nil, err
	}
	log.Printf("Successfully connected to %s", serverAddr)

	tcpConn := network.NewTCPConnection(conn)
	display := NewDisplay()
	input := NewInputHandler(display.Window, display)

	return &ClientHandler{
		conn:    tcpConn,
		display: display,
		input:   input,
		running: true,
	}, nil
}

func (h *ClientHandler) Handle() {
	defer h.conn.Close()

	h.input.Start()
	go h.handleServerMessages()
	go h.handleUserInput()

	log.Println("Starting main display loop")
	for h.running && !h.display.ShouldClose() {
		h.display.Update()
		h.display.Window.UpdateInput()
		time.Sleep(time.Millisecond * 16) // 约60 FPS
	}
	log.Println("Display loop ended")
}

func (h *ClientHandler) handleServerMessages() {
	log.Println("Started handling server messages")
	for h.running {
		msg, err := h.conn.Receive()
		if err != nil {
			log.Printf("Error receiving message from server: %v", err)
			h.running = false
			return
		}

		log.Printf("Received message type: %T", msg.Payload)

		switch payload := msg.Payload.(type) {
		case *protocol.Message_ScreenUpdate:
			log.Printf("Received screen update: %dx%d, %d bytes",
				payload.ScreenUpdate.Width,
				payload.ScreenUpdate.Height,
				len(payload.ScreenUpdate.ImageData))
			h.display.UpdateScreen(payload.ScreenUpdate)
		default:
			log.Printf("Unhandled message type: %T", payload)
		}
	}
}

func (h *ClientHandler) handleUserInput() {
	for h.running {
		event := h.input.NextEvent()
		if event == nil {
			time.Sleep(time.Millisecond * 16)
			continue
		}

		var msg *protocol.Message
		switch e := event.(type) {
		case MouseEvent:
			msg = &protocol.Message{
				Payload: &protocol.Message_MouseEvent{
					MouseEvent: &protocol.MouseEvent{
						EventType: protocol.MouseEvent_EventType(e.EventType),
						X:         int32(e.X),
						Y:         int32(e.Y),
					},
				},
			}
		case KeyEvent:
			msg = &protocol.Message{
				Payload: &protocol.Message_KeyEvent{
					KeyEvent: &protocol.KeyEvent{
						EventType: protocol.KeyEvent_EventType(e.EventType),
						KeyCode:   int32(e.KeyCode),
					},
				},
			}
		}

		if msg != nil {
			if err := h.conn.Send(msg); err != nil {
				log.Printf("Error sending input event to server: %v", err)
				h.running = false
				return
			}
		}
	}
}


========================================


File: internal/client/input.go
----------------------------------------
package client

import (
	"sync"

	"github.com/faiface/pixel"
	"github.com/faiface/pixel/pixelgl"
)

type MouseEvent struct {
	EventType int
	X, Y      float64
}

type KeyEvent struct {
	EventType int
	KeyCode   pixelgl.Button
}

type InputHandler struct {
	window  *pixelgl.Window
	events  chan interface{}
	display *Display // 添加对 Display 的引用
	mutex   sync.Mutex
}

func NewInputHandler(window *pixelgl.Window, display *Display) *InputHandler {
	return &InputHandler{
		window:  window,
		events:  make(chan interface{}, 100),
		display: display,
	}
}

func (h *InputHandler) Start() {
	go h.pollEvents()
}

func (h *InputHandler) NextEvent() interface{} {
	h.mutex.Lock()
	defer h.mutex.Unlock()

	select {
	case event := <-h.events:
		return event
	default:
		return nil
	}
}

func (h *InputHandler) pollEvents() {
	for !h.window.Closed() {
		h.mutex.Lock()
		if h.window.JustPressed(pixelgl.MouseButtonLeft) {
			pos := h.window.MousePosition()
			scaledPos := h.scaleMousePosition(pos)
			h.events <- MouseEvent{EventType: 1, X: scaledPos.X, Y: scaledPos.Y}
		}
		if h.window.JustReleased(pixelgl.MouseButtonLeft) {
			pos := h.window.MousePosition()
			scaledPos := h.scaleMousePosition(pos)
			h.events <- MouseEvent{EventType: 2, X: scaledPos.X, Y: scaledPos.Y}
		}

		// 添加键盘事件处理
		for key := pixelgl.Key0; key <= pixelgl.KeyWorld2; key++ {
			if h.window.JustPressed(key) {
				h.events <- KeyEvent{EventType: 1, KeyCode: key}
			}
			if h.window.JustReleased(key) {
				h.events <- KeyEvent{EventType: 2, KeyCode: key}
			}
		}

		h.mutex.Unlock()
		h.window.UpdateInput()
	}
	close(h.events)
}

func (h *InputHandler) scaleMousePosition(pos pixel.Vec) pixel.Vec {
	scale := min(
		h.window.Bounds().W()/h.display.spriteRect.W(),
		h.window.Bounds().H()/h.display.spriteRect.H(),
	)

	// 计算图像在窗口中的实际位置
	imagePos := h.window.Bounds().Center().Sub(h.display.spriteRect.Center().Scaled(scale))

	// 将鼠标位置从窗口坐标转换为图像坐标
	imageX := (pos.X - imagePos.X) / scale
	imageY := (pos.Y - imagePos.Y) / scale

	return pixel.V(imageX, imageY)
}


========================================


File: internal/protocol/auth.pb.go
----------------------------------------
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.34.2
// 	protoc        v5.28.0--rc2
// source: proto/auth.proto

package protocol

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type AuthRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"` // 应该是哈希后的密码
}

func (x *AuthRequest) Reset() {
	*x = AuthRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proto_auth_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AuthRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthRequest) ProtoMessage() {}

func (x *AuthRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_auth_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthRequest.ProtoReflect.Descriptor instead.
func (*AuthRequest) Descriptor() ([]byte, []int) {
	return file_proto_auth_proto_rawDescGZIP(), []int{0}
}

func (x *AuthRequest) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *AuthRequest) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

type AuthResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Success      bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Token        string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`                                   // 如果认证成功，返回一个会话token
	ErrorMessage string `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"` // 如果认证失败，返回错误信息
}

func (x *AuthResponse) Reset() {
	*x = AuthResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proto_auth_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AuthResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthResponse) ProtoMessage() {}

func (x *AuthResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_auth_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthResponse.ProtoReflect.Descriptor instead.
func (*AuthResponse) Descriptor() ([]byte, []int) {
	return file_proto_auth_proto_rawDescGZIP(), []int{1}
}

func (x *AuthResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *AuthResponse) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

func (x *AuthResponse) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

type TokenValidationRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
}

func (x *TokenValidationRequest) Reset() {
	*x = TokenValidationRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proto_auth_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TokenValidationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenValidationRequest) ProtoMessage() {}

func (x *TokenValidationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_auth_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenValidationRequest.ProtoReflect.Descriptor instead.
func (*TokenValidationRequest) Descriptor() ([]byte, []int) {
	return file_proto_auth_proto_rawDescGZIP(), []int{2}
}

func (x *TokenValidationRequest) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

type TokenValidationResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Valid    bool   `protobuf:"varint,1,opt,name=valid,proto3" json:"valid,omitempty"`
	Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"` // 如果token有效，返回关联的用户名
}

func (x *TokenValidationResponse) Reset() {
	*x = TokenValidationResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proto_auth_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TokenValidationResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenValidationResponse) ProtoMessage() {}

func (x *TokenValidationResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_auth_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenValidationResponse.ProtoReflect.Descriptor instead.
func (*TokenValidationResponse) Descriptor() ([]byte, []int) {
	return file_proto_auth_proto_rawDescGZIP(), []int{3}
}

func (x *TokenValidationResponse) GetValid() bool {
	if x != nil {
		return x.Valid
	}
	return false
}

func (x *TokenValidationResponse) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

var File_proto_auth_proto protoreflect.FileDescriptor

var file_proto_auth_proto_rawDesc = []byte{
	0x0a, 0x10, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x12, 0x06, 0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b, 0x22, 0x45, 0x0a, 0x0b, 0x41, 0x75,
	0x74, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x75, 0x73, 0x65,
	0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x75, 0x73, 0x65,
	0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72,
	0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72,
	0x64, 0x22, 0x63, 0x0a, 0x0c, 0x41, 0x75, 0x74, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x74,
	0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x6f, 0x6b, 0x65,
	0x6e, 0x12, 0x23, 0x0a, 0x0d, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61,
	0x67, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x4d,
	0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x2e, 0x0a, 0x16, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x56,
	0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x12, 0x14, 0x0a, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x4b, 0x0a, 0x17, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x56,
	0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x05, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e,
	0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e,
	0x61, 0x6d, 0x65, 0x42, 0x2c, 0x5a, 0x2a, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f,
	0x6d, 0x2f, 0x73, 0x75, 0x69, 0x66, 0x65, 0x69, 0x2f, 0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b, 0x2f,
	0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f,
	0x6c, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_proto_auth_proto_rawDescOnce sync.Once
	file_proto_auth_proto_rawDescData = file_proto_auth_proto_rawDesc
)

func file_proto_auth_proto_rawDescGZIP() []byte {
	file_proto_auth_proto_rawDescOnce.Do(func() {
		file_proto_auth_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_auth_proto_rawDescData)
	})
	return file_proto_auth_proto_rawDescData
}

var file_proto_auth_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_proto_auth_proto_goTypes = []any{
	(*AuthRequest)(nil),             // 0: godesk.AuthRequest
	(*AuthResponse)(nil),            // 1: godesk.AuthResponse
	(*TokenValidationRequest)(nil),  // 2: godesk.TokenValidationRequest
	(*TokenValidationResponse)(nil), // 3: godesk.TokenValidationResponse
}
var file_proto_auth_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_proto_auth_proto_init() }
func file_proto_auth_proto_init() {
	if File_proto_auth_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_proto_auth_proto_msgTypes[0].Exporter = func(v any, i int) any {
			switch v := v.(*AuthRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proto_auth_proto_msgTypes[1].Exporter = func(v any, i int) any {
			switch v := v.(*AuthResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proto_auth_proto_msgTypes[2].Exporter = func(v any, i int) any {
			switch v := v.(*TokenValidationRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proto_auth_proto_msgTypes[3].Exporter = func(v any, i int) any {
			switch v := v.(*TokenValidationResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_proto_auth_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   4,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proto_auth_proto_goTypes,
		DependencyIndexes: file_proto_auth_proto_depIdxs,
		MessageInfos:      file_proto_auth_proto_msgTypes,
	}.Build()
	File_proto_auth_proto = out.File
	file_proto_auth_proto_rawDesc = nil
	file_proto_auth_proto_goTypes = nil
	file_proto_auth_proto_depIdxs = nil
}


========================================


File: internal/protocol/control.pb.go
----------------------------------------
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.34.2
// 	protoc        v5.28.0--rc2
// source: proto/control.proto

package protocol

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type MouseEvent_EventType int32

const (
	MouseEvent_MOVE        MouseEvent_EventType = 0
	MouseEvent_LEFT_DOWN   MouseEvent_EventType = 1
	MouseEvent_LEFT_UP     MouseEvent_EventType = 2
	MouseEvent_RIGHT_DOWN  MouseEvent_EventType = 3
	MouseEvent_RIGHT_UP    MouseEvent_EventType = 4
	MouseEvent_MIDDLE_DOWN MouseEvent_EventType = 5
	MouseEvent_MIDDLE_UP   MouseEvent_EventType = 6
	MouseEvent_SCROLL      MouseEvent_EventType = 7
)

// Enum value maps for MouseEvent_EventType.
var (
	MouseEvent_EventType_name = map[int32]string{
		0: "MOVE",
		1: "LEFT_DOWN",
		2: "LEFT_UP",
		3: "RIGHT_DOWN",
		4: "RIGHT_UP",
		5: "MIDDLE_DOWN",
		6: "MIDDLE_UP",
		7: "SCROLL",
	}
	MouseEvent_EventType_value = map[string]int32{
		"MOVE":        0,
		"LEFT_DOWN":   1,
		"LEFT_UP":     2,
		"RIGHT_DOWN":  3,
		"RIGHT_UP":    4,
		"MIDDLE_DOWN": 5,
		"MIDDLE_UP":   6,
		"SCROLL":      7,
	}
)

func (x MouseEvent_EventType) Enum() *MouseEvent_EventType {
	p := new(MouseEvent_EventType)
	*p = x
	return p
}

func (x MouseEvent_EventType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MouseEvent_EventType) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_control_proto_enumTypes[0].Descriptor()
}

func (MouseEvent_EventType) Type() protoreflect.EnumType {
	return &file_proto_control_proto_enumTypes[0]
}

func (x MouseEvent_EventType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MouseEvent_EventType.Descriptor instead.
func (MouseEvent_EventType) EnumDescriptor() ([]byte, []int) {
	return file_proto_control_proto_rawDescGZIP(), []int{0, 0}
}

type KeyEvent_EventType int32

const (
	KeyEvent_KEY_DOWN KeyEvent_EventType = 0
	KeyEvent_KEY_UP   KeyEvent_EventType = 1
)

// Enum value maps for KeyEvent_EventType.
var (
	KeyEvent_EventType_name = map[int32]string{
		0: "KEY_DOWN",
		1: "KEY_UP",
	}
	KeyEvent_EventType_value = map[string]int32{
		"KEY_DOWN": 0,
		"KEY_UP":   1,
	}
)

func (x KeyEvent_EventType) Enum() *KeyEvent_EventType {
	p := new(KeyEvent_EventType)
	*p = x
	return p
}

func (x KeyEvent_EventType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (KeyEvent_EventType) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_control_proto_enumTypes[1].Descriptor()
}

func (KeyEvent_EventType) Type() protoreflect.EnumType {
	return &file_proto_control_proto_enumTypes[1]
}

func (x KeyEvent_EventType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use KeyEvent_EventType.Descriptor instead.
func (KeyEvent_EventType) EnumDescriptor() ([]byte, []int) {
	return file_proto_control_proto_rawDescGZIP(), []int{1, 0}
}

type MouseEvent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	EventType   MouseEvent_EventType `protobuf:"varint,1,opt,name=event_type,json=eventType,proto3,enum=godesk.MouseEvent_EventType" json:"event_type,omitempty"`
	X           int32                `protobuf:"varint,2,opt,name=x,proto3" json:"x,omitempty"`
	Y           int32                `protobuf:"varint,3,opt,name=y,proto3" json:"y,omitempty"`
	ScrollDelta int32                `protobuf:"varint,4,opt,name=scroll_delta,json=scrollDelta,proto3" json:"scroll_delta,omitempty"` // 用于滚轮事件
}

func (x *MouseEvent) Reset() {
	*x = MouseEvent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proto_control_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MouseEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MouseEvent) ProtoMessage() {}

func (x *MouseEvent) ProtoReflect() protoreflect.Message {
	mi := &file_proto_control_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MouseEvent.ProtoReflect.Descriptor instead.
func (*MouseEvent) Descriptor() ([]byte, []int) {
	return file_proto_control_proto_rawDescGZIP(), []int{0}
}

func (x *MouseEvent) GetEventType() MouseEvent_EventType {
	if x != nil {
		return x.EventType
	}
	return MouseEvent_MOVE
}

func (x *MouseEvent) GetX() int32 {
	if x != nil {
		return x.X
	}
	return 0
}

func (x *MouseEvent) GetY() int32 {
	if x != nil {
		return x.Y
	}
	return 0
}

func (x *MouseEvent) GetScrollDelta() int32 {
	if x != nil {
		return x.ScrollDelta
	}
	return 0
}

type KeyEvent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	EventType KeyEvent_EventType `protobuf:"varint,1,opt,name=event_type,json=eventType,proto3,enum=godesk.KeyEvent_EventType" json:"event_type,omitempty"`
	KeyCode   int32              `protobuf:"varint,2,opt,name=key_code,json=keyCode,proto3" json:"key_code,omitempty"`
	Shift     bool               `protobuf:"varint,3,opt,name=shift,proto3" json:"shift,omitempty"`
	Ctrl      bool               `protobuf:"varint,4,opt,name=ctrl,proto3" json:"ctrl,omitempty"`
	Alt       bool               `protobuf:"varint,5,opt,name=alt,proto3" json:"alt,omitempty"`
	Meta      bool               `protobuf:"varint,6,opt,name=meta,proto3" json:"meta,omitempty"` // Windows键或Command键
}

func (x *KeyEvent) Reset() {
	*x = KeyEvent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proto_control_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *KeyEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyEvent) ProtoMessage() {}

func (x *KeyEvent) ProtoReflect() protoreflect.Message {
	mi := &file_proto_control_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyEvent.ProtoReflect.Descriptor instead.
func (*KeyEvent) Descriptor() ([]byte, []int) {
	return file_proto_control_proto_rawDescGZIP(), []int{1}
}

func (x *KeyEvent) GetEventType() KeyEvent_EventType {
	if x != nil {
		return x.EventType
	}
	return KeyEvent_KEY_DOWN
}

func (x *KeyEvent) GetKeyCode() int32 {
	if x != nil {
		return x.KeyCode
	}
	return 0
}

func (x *KeyEvent) GetShift() bool {
	if x != nil {
		return x.Shift
	}
	return false
}

func (x *KeyEvent) GetCtrl() bool {
	if x != nil {
		return x.Ctrl
	}
	return false
}

func (x *KeyEvent) GetAlt() bool {
	if x != nil {
		return x.Alt
	}
	return false
}

func (x *KeyEvent) GetMeta() bool {
	if x != nil {
		return x.Meta
	}
	return false
}

var File_proto_control_proto protoreflect.FileDescriptor

var file_proto_control_proto_rawDesc = []byte{
	0x0a, 0x13, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x06, 0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b, 0x22, 0x85, 0x02,
	0x0a, 0x0a, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x3b, 0x0a, 0x0a,
	0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x1c, 0x2e, 0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b, 0x2e, 0x4d, 0x6f, 0x75, 0x73, 0x65, 0x45,
	0x76, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x79, 0x70, 0x65, 0x52, 0x09,
	0x65, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0c, 0x0a, 0x01, 0x78, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x05, 0x52, 0x01, 0x78, 0x12, 0x0c, 0x0a, 0x01, 0x79, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x01, 0x79, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x63, 0x72, 0x6f, 0x6c, 0x6c, 0x5f,
	0x64, 0x65, 0x6c, 0x74, 0x61, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0b, 0x73, 0x63, 0x72,
	0x6f, 0x6c, 0x6c, 0x44, 0x65, 0x6c, 0x74, 0x61, 0x22, 0x7b, 0x0a, 0x09, 0x45, 0x76, 0x65, 0x6e,
	0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x08, 0x0a, 0x04, 0x4d, 0x4f, 0x56, 0x45, 0x10, 0x00, 0x12,
	0x0d, 0x0a, 0x09, 0x4c, 0x45, 0x46, 0x54, 0x5f, 0x44, 0x4f, 0x57, 0x4e, 0x10, 0x01, 0x12, 0x0b,
	0x0a, 0x07, 0x4c, 0x45, 0x46, 0x54, 0x5f, 0x55, 0x50, 0x10, 0x02, 0x12, 0x0e, 0x0a, 0x0a, 0x52,
	0x49, 0x47, 0x48, 0x54, 0x5f, 0x44, 0x4f, 0x57, 0x4e, 0x10, 0x03, 0x12, 0x0c, 0x0a, 0x08, 0x52,
	0x49, 0x47, 0x48, 0x54, 0x5f, 0x55, 0x50, 0x10, 0x04, 0x12, 0x0f, 0x0a, 0x0b, 0x4d, 0x49, 0x44,
	0x44, 0x4c, 0x45, 0x5f, 0x44, 0x4f, 0x57, 0x4e, 0x10, 0x05, 0x12, 0x0d, 0x0a, 0x09, 0x4d, 0x49,
	0x44, 0x44, 0x4c, 0x45, 0x5f, 0x55, 0x50, 0x10, 0x06, 0x12, 0x0a, 0x0a, 0x06, 0x53, 0x43, 0x52,
	0x4f, 0x4c, 0x4c, 0x10, 0x07, 0x22, 0xd7, 0x01, 0x0a, 0x08, 0x4b, 0x65, 0x79, 0x45, 0x76, 0x65,
	0x6e, 0x74, 0x12, 0x39, 0x0a, 0x0a, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x74, 0x79, 0x70, 0x65,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b, 0x2e,
	0x4b, 0x65, 0x79, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x79,
	0x70, 0x65, 0x52, 0x09, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x19, 0x0a,
	0x08, 0x6b, 0x65, 0x79, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52,
	0x07, 0x6b, 0x65, 0x79, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x68, 0x69, 0x66,
	0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x05, 0x73, 0x68, 0x69, 0x66, 0x74, 0x12, 0x12,
	0x0a, 0x04, 0x63, 0x74, 0x72, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x04, 0x63, 0x74,
	0x72, 0x6c, 0x12, 0x10, 0x0a, 0x03, 0x61, 0x6c, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x03, 0x61, 0x6c, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x22, 0x25, 0x0a, 0x09, 0x45, 0x76, 0x65, 0x6e,
	0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0c, 0x0a, 0x08, 0x4b, 0x45, 0x59, 0x5f, 0x44, 0x4f, 0x57,
	0x4e, 0x10, 0x00, 0x12, 0x0a, 0x0a, 0x06, 0x4b, 0x45, 0x59, 0x5f, 0x55, 0x50, 0x10, 0x01, 0x42,
	0x2c, 0x5a, 0x2a, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x73, 0x75,
	0x69, 0x66, 0x65, 0x69, 0x2f, 0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b, 0x2f, 0x69, 0x6e, 0x74, 0x65,
	0x72, 0x6e, 0x61, 0x6c, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x62, 0x06, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_proto_control_proto_rawDescOnce sync.Once
	file_proto_control_proto_rawDescData = file_proto_control_proto_rawDesc
)

func file_proto_control_proto_rawDescGZIP() []byte {
	file_proto_control_proto_rawDescOnce.Do(func() {
		file_proto_control_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_control_proto_rawDescData)
	})
	return file_proto_control_proto_rawDescData
}

var file_proto_control_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_proto_control_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_proto_control_proto_goTypes = []any{
	(MouseEvent_EventType)(0), // 0: godesk.MouseEvent.EventType
	(KeyEvent_EventType)(0),   // 1: godesk.KeyEvent.EventType
	(*MouseEvent)(nil),        // 2: godesk.MouseEvent
	(*KeyEvent)(nil),          // 3: godesk.KeyEvent
}
var file_proto_control_proto_depIdxs = []int32{
	0, // 0: godesk.MouseEvent.event_type:type_name -> godesk.MouseEvent.EventType
	1, // 1: godesk.KeyEvent.event_type:type_name -> godesk.KeyEvent.EventType
	2, // [2:2] is the sub-list for method output_type
	2, // [2:2] is the sub-list for method input_type
	2, // [2:2] is the sub-list for extension type_name
	2, // [2:2] is the sub-list for extension extendee
	0, // [0:2] is the sub-list for field type_name
}

func init() { file_proto_control_proto_init() }
func file_proto_control_proto_init() {
	if File_proto_control_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_proto_control_proto_msgTypes[0].Exporter = func(v any, i int) any {
			switch v := v.(*MouseEvent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proto_control_proto_msgTypes[1].Exporter = func(v any, i int) any {
			switch v := v.(*KeyEvent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_proto_control_proto_rawDesc,
			NumEnums:      2,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proto_control_proto_goTypes,
		DependencyIndexes: file_proto_control_proto_depIdxs,
		EnumInfos:         file_proto_control_proto_enumTypes,
		MessageInfos:      file_proto_control_proto_msgTypes,
	}.Build()
	File_proto_control_proto = out.File
	file_proto_control_proto_rawDesc = nil
	file_proto_control_proto_goTypes = nil
	file_proto_control_proto_depIdxs = nil
}


========================================


File: internal/protocol/filetransfer.pb.go
----------------------------------------
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.34.2
// 	protoc        v5.28.0--rc2
// source: proto/filetransfer.proto

package protocol

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type FileTransferStatus_Status int32

const (
	FileTransferStatus_IN_PROGRESS FileTransferStatus_Status = 0
	FileTransferStatus_COMPLETED   FileTransferStatus_Status = 1
	FileTransferStatus_FAILED      FileTransferStatus_Status = 2
)

// Enum value maps for FileTransferStatus_Status.
var (
	FileTransferStatus_Status_name = map[int32]string{
		0: "IN_PROGRESS",
		1: "COMPLETED",
		2: "FAILED",
	}
	FileTransferStatus_Status_value = map[string]int32{
		"IN_PROGRESS": 0,
		"COMPLETED":   1,
		"FAILED":      2,
	}
)

func (x FileTransferStatus_Status) Enum() *FileTransferStatus_Status {
	p := new(FileTransferStatus_Status)
	*p = x
	return p
}

func (x FileTransferStatus_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FileTransferStatus_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_filetransfer_proto_enumTypes[0].Descriptor()
}

func (FileTransferStatus_Status) Type() protoreflect.EnumType {
	return &file_proto_filetransfer_proto_enumTypes[0]
}

func (x FileTransferStatus_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FileTransferStatus_Status.Descriptor instead.
func (FileTransferStatus_Status) EnumDescriptor() ([]byte, []int) {
	return file_proto_filetransfer_proto_rawDescGZIP(), []int{3, 0}
}

type FileTransferRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	FileName        string `protobuf:"bytes,1,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	FileSize        int64  `protobuf:"varint,2,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	DestinationPath string `protobuf:"bytes,3,opt,name=destination_path,json=destinationPath,proto3" json:"destination_path,omitempty"`
}

func (x *FileTransferRequest) Reset() {
	*x = FileTransferRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proto_filetransfer_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FileTransferRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileTransferRequest) ProtoMessage() {}

func (x *FileTransferRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_filetransfer_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileTransferRequest.ProtoReflect.Descriptor instead.
func (*FileTransferRequest) Descriptor() ([]byte, []int) {
	return file_proto_filetransfer_proto_rawDescGZIP(), []int{0}
}

func (x *FileTransferRequest) GetFileName() string {
	if x != nil {
		return x.FileName
	}
	return ""
}

func (x *FileTransferRequest) GetFileSize() int64 {
	if x != nil {
		return x.FileSize
	}
	return 0
}

func (x *FileTransferRequest) GetDestinationPath() string {
	if x != nil {
		return x.DestinationPath
	}
	return ""
}

type FileTransferResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Accepted     bool   `protobuf:"varint,1,opt,name=accepted,proto3" json:"accepted,omitempty"`
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (x *FileTransferResponse) Reset() {
	*x = FileTransferResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proto_filetransfer_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FileTransferResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileTransferResponse) ProtoMessage() {}

func (x *FileTransferResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_filetransfer_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileTransferResponse.ProtoReflect.Descriptor instead.
func (*FileTransferResponse) Descriptor() ([]byte, []int) {
	return file_proto_filetransfer_proto_rawDescGZIP(), []int{1}
}

func (x *FileTransferResponse) GetAccepted() bool {
	if x != nil {
		return x.Accepted
	}
	return false
}

func (x *FileTransferResponse) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

type FileChunk struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Data   []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Offset int64  `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (x *FileChunk) Reset() {
	*x = FileChunk{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proto_filetransfer_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FileChunk) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileChunk) ProtoMessage() {}

func (x *FileChunk) ProtoReflect() protoreflect.Message {
	mi := &file_proto_filetransfer_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileChunk.ProtoReflect.Descriptor instead.
func (*FileChunk) Descriptor() ([]byte, []int) {
	return file_proto_filetransfer_proto_rawDescGZIP(), []int{2}
}

func (x *FileChunk) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *FileChunk) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type FileTransferStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Status           FileTransferStatus_Status `protobuf:"varint,1,opt,name=status,proto3,enum=godesk.FileTransferStatus_Status" json:"status,omitempty"`
	BytesTransferred int64                     `protobuf:"varint,2,opt,name=bytes_transferred,json=bytesTransferred,proto3" json:"bytes_transferred,omitempty"`
	ErrorMessage     string                    `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (x *FileTransferStatus) Reset() {
	*x = FileTransferStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proto_filetransfer_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FileTransferStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileTransferStatus) ProtoMessage() {}

func (x *FileTransferStatus) ProtoReflect() protoreflect.Message {
	mi := &file_proto_filetransfer_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileTransferStatus.ProtoReflect.Descriptor instead.
func (*FileTransferStatus) Descriptor() ([]byte, []int) {
	return file_proto_filetransfer_proto_rawDescGZIP(), []int{3}
}

func (x *FileTransferStatus) GetStatus() FileTransferStatus_Status {
	if x != nil {
		return x.Status
	}
	return FileTransferStatus_IN_PROGRESS
}

func (x *FileTransferStatus) GetBytesTransferred() int64 {
	if x != nil {
		return x.BytesTransferred
	}
	return 0
}

func (x *FileTransferStatus) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

var File_proto_filetransfer_proto protoreflect.FileDescriptor

var file_proto_filetransfer_proto_rawDesc = []byte{
	0x0a, 0x18, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x66, 0x69, 0x6c, 0x65, 0x74, 0x72, 0x61, 0x6e,
	0x73, 0x66, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x06, 0x67, 0x6f, 0x64, 0x65,
	0x73, 0x6b, 0x22, 0x7a, 0x0a, 0x13, 0x46, 0x69, 0x6c, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66,
	0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x66, 0x69, 0x6c,
	0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x66, 0x69,
	0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x73,
	0x69, 0x7a, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x53,
	0x69, 0x7a, 0x65, 0x12, 0x29, 0x0a, 0x10, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x64,
	0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x61, 0x74, 0x68, 0x22, 0x57,
	0x0a, 0x14, 0x46, 0x69, 0x6c, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74,
	0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74,
	0x65, 0x64, 0x12, 0x23, 0x0a, 0x0d, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x6d, 0x65, 0x73, 0x73,
	0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x65, 0x72, 0x72, 0x6f, 0x72,
	0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x37, 0x0a, 0x09, 0x46, 0x69, 0x6c, 0x65, 0x43,
	0x68, 0x75, 0x6e, 0x6b, 0x12, 0x12, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0c, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73,
	0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74,
	0x22, 0xd7, 0x01, 0x0a, 0x12, 0x46, 0x69, 0x6c, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65,
	0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x39, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x21, 0x2e, 0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b,
	0x2e, 0x46, 0x69, 0x6c, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x12, 0x2b, 0x0a, 0x11, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x74, 0x72, 0x61, 0x6e,
	0x73, 0x66, 0x65, 0x72, 0x72, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x10, 0x62,
	0x79, 0x74, 0x65, 0x73, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x72, 0x65, 0x64, 0x12,
	0x23, 0x0a, 0x0d, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x4d, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65, 0x22, 0x34, 0x0a, 0x06, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x0f,
	0x0a, 0x0b, 0x49, 0x4e, 0x5f, 0x50, 0x52, 0x4f, 0x47, 0x52, 0x45, 0x53, 0x53, 0x10, 0x00, 0x12,
	0x0d, 0x0a, 0x09, 0x43, 0x4f, 0x4d, 0x50, 0x4c, 0x45, 0x54, 0x45, 0x44, 0x10, 0x01, 0x12, 0x0a,
	0x0a, 0x06, 0x46, 0x41, 0x49, 0x4c, 0x45, 0x44, 0x10, 0x02, 0x42, 0x2c, 0x5a, 0x2a, 0x67, 0x69,
	0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x73, 0x75, 0x69, 0x66, 0x65, 0x69, 0x2f,
	0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x2f,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_proto_filetransfer_proto_rawDescOnce sync.Once
	file_proto_filetransfer_proto_rawDescData = file_proto_filetransfer_proto_rawDesc
)

func file_proto_filetransfer_proto_rawDescGZIP() []byte {
	file_proto_filetransfer_proto_rawDescOnce.Do(func() {
		file_proto_filetransfer_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_filetransfer_proto_rawDescData)
	})
	return file_proto_filetransfer_proto_rawDescData
}

var file_proto_filetransfer_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_proto_filetransfer_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_proto_filetransfer_proto_goTypes = []any{
	(FileTransferStatus_Status)(0), // 0: godesk.FileTransferStatus.Status
	(*FileTransferRequest)(nil),    // 1: godesk.FileTransferRequest
	(*FileTransferResponse)(nil),   // 2: godesk.FileTransferResponse
	(*FileChunk)(nil),              // 3: godesk.FileChunk
	(*FileTransferStatus)(nil),     // 4: godesk.FileTransferStatus
}
var file_proto_filetransfer_proto_depIdxs = []int32{
	0, // 0: godesk.FileTransferStatus.status:type_name -> godesk.FileTransferStatus.Status
	1, // [1:1] is the sub-list for method output_type
	1, // [1:1] is the sub-list for method input_type
	1, // [1:1] is the sub-list for extension type_name
	1, // [1:1] is the sub-list for extension extendee
	0, // [0:1] is the sub-list for field type_name
}

func init() { file_proto_filetransfer_proto_init() }
func file_proto_filetransfer_proto_init() {
	if File_proto_filetransfer_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_proto_filetransfer_proto_msgTypes[0].Exporter = func(v any, i int) any {
			switch v := v.(*FileTransferRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proto_filetransfer_proto_msgTypes[1].Exporter = func(v any, i int) any {
			switch v := v.(*FileTransferResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proto_filetransfer_proto_msgTypes[2].Exporter = func(v any, i int) any {
			switch v := v.(*FileChunk); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proto_filetransfer_proto_msgTypes[3].Exporter = func(v any, i int) any {
			switch v := v.(*FileTransferStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_proto_filetransfer_proto_rawDesc,
			NumEnums:      1,
			NumMessages:   4,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proto_filetransfer_proto_goTypes,
		DependencyIndexes: file_proto_filetransfer_proto_depIdxs,
		EnumInfos:         file_proto_filetransfer_proto_enumTypes,
		MessageInfos:      file_proto_filetransfer_proto_msgTypes,
	}.Build()
	File_proto_filetransfer_proto = out.File
	file_proto_filetransfer_proto_rawDesc = nil
	file_proto_filetransfer_proto_goTypes = nil
	file_proto_filetransfer_proto_depIdxs = nil
}


========================================


File: internal/protocol/message.pb.go
----------------------------------------
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.34.2
// 	protoc        v5.28.0--rc2
// source: proto/message.proto

package protocol

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Message struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Payload:
	//
	//	*Message_ScreenUpdate
	//	*Message_ScreenUpdateRequest
	//	*Message_MouseEvent
	//	*Message_KeyEvent
	//	*Message_AuthRequest
	//	*Message_AuthResponse
	//	*Message_FileTransferRequest
	//	*Message_FileTransferResponse
	//	*Message_FileChunk
	//	*Message_FileTransferStatus
	//	*Message_RelayHandshake
	//	*Message_RelayMessage
	//	*Message_RelayStatus
	Payload isMessage_Payload `protobuf_oneof:"payload"`
}

func (x *Message) Reset() {
	*x = Message{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proto_message_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Message) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Message) ProtoMessage() {}

func (x *Message) ProtoReflect() protoreflect.Message {
	mi := &file_proto_message_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Message.ProtoReflect.Descriptor instead.
func (*Message) Descriptor() ([]byte, []int) {
	return file_proto_message_proto_rawDescGZIP(), []int{0}
}

func (m *Message) GetPayload() isMessage_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (x *Message) GetScreenUpdate() *ScreenUpdate {
	if x, ok := x.GetPayload().(*Message_ScreenUpdate); ok {
		return x.ScreenUpdate
	}
	return nil
}

func (x *Message) GetScreenUpdateRequest() *ScreenUpdateRequest {
	if x, ok := x.GetPayload().(*Message_ScreenUpdateRequest); ok {
		return x.ScreenUpdateRequest
	}
	return nil
}

func (x *Message) GetMouseEvent() *MouseEvent {
	if x, ok := x.GetPayload().(*Message_MouseEvent); ok {
		return x.MouseEvent
	}
	return nil
}

func (x *Message) GetKeyEvent() *KeyEvent {
	if x, ok := x.GetPayload().(*Message_KeyEvent); ok {
		return x.KeyEvent
	}
	return nil
}

func (x *Message) GetAuthRequest() *AuthRequest {
	if x, ok := x.GetPayload().(*Message_AuthRequest); ok {
		return x.AuthRequest
	}
	return nil
}

func (x *Message) GetAuthResponse() *AuthResponse {
	if x, ok := x.GetPayload().(*Message_AuthResponse); ok {
		return x.AuthResponse
	}
	return nil
}

func (x *Message) GetFileTransferRequest() *FileTransferRequest {
	if x, ok := x.GetPayload().(*Message_FileTransferRequest); ok {
		return x.FileTransferRequest
	}
	return nil
}

func (x *Message) GetFileTransferResponse() *FileTransferResponse {
	if x, ok := x.GetPayload().(*Message_FileTransferResponse); ok {
		return x.FileTransferResponse
	}
	return nil
}

func (x *Message) GetFileChunk() *FileChunk {
	if x, ok := x.GetPayload().(*Message_FileChunk); ok {
		return x.FileChunk
	}
	return nil
}

func (x *Message) GetFileTransferStatus() *FileTransferStatus {
	if x, ok := x.GetPayload().(*Message_FileTransferStatus); ok {
		return x.FileTransferStatus
	}
	return nil
}

func (x *Message) GetRelayHandshake() *RelayHandshake {
	if x, ok := x.GetPayload().(*Message_RelayHandshake); ok {
		return x.RelayHandshake
	}
	return nil
}

func (x *Message) GetRelayMessage() *RelayMessage {
	if x, ok := x.GetPayload().(*Message_RelayMessage); ok {
		return x.RelayMessage
	}
	return nil
}

func (x *Message) GetRelayStatus() *RelayStatus {
	if x, ok := x.GetPayload().(*Message_RelayStatus); ok {
		return x.RelayStatus
	}
	return nil
}

type isMessage_Payload interface {
	isMessage_Payload()
}

type Message_ScreenUpdate struct {
	ScreenUpdate *ScreenUpdate `protobuf:"bytes,1,opt,name=screen_update,json=screenUpdate,proto3,oneof"`
}

type Message_ScreenUpdateRequest struct {
	ScreenUpdateRequest *ScreenUpdateRequest `protobuf:"bytes,2,opt,name=screen_update_request,json=screenUpdateRequest,proto3,oneof"`
}

type Message_MouseEvent struct {
	MouseEvent *MouseEvent `protobuf:"bytes,3,opt,name=mouse_event,json=mouseEvent,proto3,oneof"`
}

type Message_KeyEvent struct {
	KeyEvent *KeyEvent `protobuf:"bytes,4,opt,name=key_event,json=keyEvent,proto3,oneof"`
}

type Message_AuthRequest struct {
	AuthRequest *AuthRequest `protobuf:"bytes,5,opt,name=auth_request,json=authRequest,proto3,oneof"`
}

type Message_AuthResponse struct {
	AuthResponse *AuthResponse `protobuf:"bytes,6,opt,name=auth_response,json=authResponse,proto3,oneof"`
}

type Message_FileTransferRequest struct {
	FileTransferRequest *FileTransferRequest `protobuf:"bytes,7,opt,name=file_transfer_request,json=fileTransferRequest,proto3,oneof"`
}

type Message_FileTransferResponse struct {
	FileTransferResponse *FileTransferResponse `protobuf:"bytes,8,opt,name=file_transfer_response,json=fileTransferResponse,proto3,oneof"`
}

type Message_FileChunk struct {
	FileChunk *FileChunk `protobuf:"bytes,9,opt,name=file_chunk,json=fileChunk,proto3,oneof"`
}

type Message_FileTransferStatus struct {
	FileTransferStatus *FileTransferStatus `protobuf:"bytes,10,opt,name=file_transfer_status,json=fileTransferStatus,proto3,oneof"`
}

type Message_RelayHandshake struct {
	RelayHandshake *RelayHandshake `protobuf:"bytes,11,opt,name=relay_handshake,json=relayHandshake,proto3,oneof"`
}

type Message_RelayMessage struct {
	RelayMessage *RelayMessage `protobuf:"bytes,12,opt,name=relay_message,json=relayMessage,proto3,oneof"`
}

type Message_RelayStatus struct {
	RelayStatus *RelayStatus `protobuf:"bytes,13,opt,name=relay_status,json=relayStatus,proto3,oneof"`
}

func (*Message_ScreenUpdate) isMessage_Payload() {}

func (*Message_ScreenUpdateRequest) isMessage_Payload() {}

func (*Message_MouseEvent) isMessage_Payload() {}

func (*Message_KeyEvent) isMessage_Payload() {}

func (*Message_AuthRequest) isMessage_Payload() {}

func (*Message_AuthResponse) isMessage_Payload() {}

func (*Message_FileTransferRequest) isMessage_Payload() {}

func (*Message_FileTransferResponse) isMessage_Payload() {}

func (*Message_FileChunk) isMessage_Payload() {}

func (*Message_FileTransferStatus) isMessage_Payload() {}

func (*Message_RelayHandshake) isMessage_Payload() {}

func (*Message_RelayMessage) isMessage_Payload() {}

func (*Message_RelayStatus) isMessage_Payload() {}

var File_proto_message_proto protoreflect.FileDescriptor

var file_proto_message_proto_rawDesc = []byte{
	0x0a, 0x13, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x06, 0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b, 0x1a, 0x12, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x73, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x1a, 0x13, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x10, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x61, 0x75,
	0x74, 0x68, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x18, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f,
	0x66, 0x69, 0x6c, 0x65, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x1a, 0x11, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x72, 0x65, 0x6c, 0x61, 0x79, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xea, 0x06, 0x0a, 0x07, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67,
	0x65, 0x12, 0x3b, 0x0a, 0x0d, 0x73, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x5f, 0x75, 0x70, 0x64, 0x61,
	0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x67, 0x6f, 0x64, 0x65, 0x73,
	0x6b, 0x2e, 0x53, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x48, 0x00,
	0x52, 0x0c, 0x73, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x12, 0x51,
	0x0a, 0x15, 0x73, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x5f,
	0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e,
	0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b, 0x2e, 0x53, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x55, 0x70, 0x64,
	0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x48, 0x00, 0x52, 0x13, 0x73, 0x63,
	0x72, 0x65, 0x65, 0x6e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x12, 0x35, 0x0a, 0x0b, 0x6d, 0x6f, 0x75, 0x73, 0x65, 0x5f, 0x65, 0x76, 0x65, 0x6e, 0x74,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b, 0x2e,
	0x4d, 0x6f, 0x75, 0x73, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x48, 0x00, 0x52, 0x0a, 0x6d, 0x6f,
	0x75, 0x73, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x2f, 0x0a, 0x09, 0x6b, 0x65, 0x79, 0x5f,
	0x65, 0x76, 0x65, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x67, 0x6f,
	0x64, 0x65, 0x73, 0x6b, 0x2e, 0x4b, 0x65, 0x79, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x48, 0x00, 0x52,
	0x08, 0x6b, 0x65, 0x79, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x38, 0x0a, 0x0c, 0x61, 0x75, 0x74,
	0x68, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x13, 0x2e, 0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b, 0x2e, 0x41, 0x75, 0x74, 0x68, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x48, 0x00, 0x52, 0x0b, 0x61, 0x75, 0x74, 0x68, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x12, 0x3b, 0x0a, 0x0d, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x72, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x67, 0x6f, 0x64,
	0x65, 0x73, 0x6b, 0x2e, 0x41, 0x75, 0x74, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x48, 0x00, 0x52, 0x0c, 0x61, 0x75, 0x74, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x12, 0x51, 0x0a, 0x15, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65,
	0x72, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1b, 0x2e, 0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x54, 0x72, 0x61,
	0x6e, 0x73, 0x66, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x48, 0x00, 0x52, 0x13,
	0x66, 0x69, 0x6c, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x12, 0x54, 0x0a, 0x16, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x74, 0x72, 0x61, 0x6e,
	0x73, 0x66, 0x65, 0x72, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x18, 0x08, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b, 0x2e, 0x46, 0x69, 0x6c,
	0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x48, 0x00, 0x52, 0x14, 0x66, 0x69, 0x6c, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65,
	0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x32, 0x0a, 0x0a, 0x66, 0x69, 0x6c,
	0x65, 0x5f, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e,
	0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x43, 0x68, 0x75, 0x6e, 0x6b,
	0x48, 0x00, 0x52, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x43, 0x68, 0x75, 0x6e, 0x6b, 0x12, 0x4e, 0x0a,
	0x14, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x5f, 0x73,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f,
	0x64, 0x65, 0x73, 0x6b, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65,
	0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x48, 0x00, 0x52, 0x12, 0x66, 0x69, 0x6c, 0x65, 0x54,
	0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x41, 0x0a,
	0x0f, 0x72, 0x65, 0x6c, 0x61, 0x79, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x73, 0x68, 0x61, 0x6b, 0x65,
	0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b, 0x2e,
	0x52, 0x65, 0x6c, 0x61, 0x79, 0x48, 0x61, 0x6e, 0x64, 0x73, 0x68, 0x61, 0x6b, 0x65, 0x48, 0x00,
	0x52, 0x0e, 0x72, 0x65, 0x6c, 0x61, 0x79, 0x48, 0x61, 0x6e, 0x64, 0x73, 0x68, 0x61, 0x6b, 0x65,
	0x12, 0x3b, 0x0a, 0x0d, 0x72, 0x65, 0x6c, 0x61, 0x79, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
	0x65, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b,
	0x2e, 0x52, 0x65, 0x6c, 0x61, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x48, 0x00, 0x52,
	0x0c, 0x72, 0x65, 0x6c, 0x61, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x38, 0x0a,
	0x0c, 0x72, 0x65, 0x6c, 0x61, 0x79, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x0d, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b, 0x2e, 0x52, 0x65, 0x6c,
	0x61, 0x79, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x48, 0x00, 0x52, 0x0b, 0x72, 0x65, 0x6c, 0x61,
	0x79, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x42, 0x09, 0x0a, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f,
	0x61, 0x64, 0x42, 0x2c, 0x5a, 0x2a, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
	0x2f, 0x73, 0x75, 0x69, 0x66, 0x65, 0x69, 0x2f, 0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b, 0x2f, 0x69,
	0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,
	0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_proto_message_proto_rawDescOnce sync.Once
	file_proto_message_proto_rawDescData = file_proto_message_proto_rawDesc
)

func file_proto_message_proto_rawDescGZIP() []byte {
	file_proto_message_proto_rawDescOnce.Do(func() {
		file_proto_message_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_message_proto_rawDescData)
	})
	return file_proto_message_proto_rawDescData
}

var file_proto_message_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_proto_message_proto_goTypes = []any{
	(*Message)(nil),              // 0: godesk.Message
	(*ScreenUpdate)(nil),         // 1: godesk.ScreenUpdate
	(*ScreenUpdateRequest)(nil),  // 2: godesk.ScreenUpdateRequest
	(*MouseEvent)(nil),           // 3: godesk.MouseEvent
	(*KeyEvent)(nil),             // 4: godesk.KeyEvent
	(*AuthRequest)(nil),          // 5: godesk.AuthRequest
	(*AuthResponse)(nil),         // 6: godesk.AuthResponse
	(*FileTransferRequest)(nil),  // 7: godesk.FileTransferRequest
	(*FileTransferResponse)(nil), // 8: godesk.FileTransferResponse
	(*FileChunk)(nil),            // 9: godesk.FileChunk
	(*FileTransferStatus)(nil),   // 10: godesk.FileTransferStatus
	(*RelayHandshake)(nil),       // 11: godesk.RelayHandshake
	(*RelayMessage)(nil),         // 12: godesk.RelayMessage
	(*RelayStatus)(nil),          // 13: godesk.RelayStatus
}
var file_proto_message_proto_depIdxs = []int32{
	1,  // 0: godesk.Message.screen_update:type_name -> godesk.ScreenUpdate
	2,  // 1: godesk.Message.screen_update_request:type_name -> godesk.ScreenUpdateRequest
	3,  // 2: godesk.Message.mouse_event:type_name -> godesk.MouseEvent
	4,  // 3: godesk.Message.key_event:type_name -> godesk.KeyEvent
	5,  // 4: godesk.Message.auth_request:type_name -> godesk.AuthRequest
	6,  // 5: godesk.Message.auth_response:type_name -> godesk.AuthResponse
	7,  // 6: godesk.Message.file_transfer_request:type_name -> godesk.FileTransferRequest
	8,  // 7: godesk.Message.file_transfer_response:type_name -> godesk.FileTransferResponse
	9,  // 8: godesk.Message.file_chunk:type_name -> godesk.FileChunk
	10, // 9: godesk.Message.file_transfer_status:type_name -> godesk.FileTransferStatus
	11, // 10: godesk.Message.relay_handshake:type_name -> godesk.RelayHandshake
	12, // 11: godesk.Message.relay_message:type_name -> godesk.RelayMessage
	13, // 12: godesk.Message.relay_status:type_name -> godesk.RelayStatus
	13, // [13:13] is the sub-list for method output_type
	13, // [13:13] is the sub-list for method input_type
	13, // [13:13] is the sub-list for extension type_name
	13, // [13:13] is the sub-list for extension extendee
	0,  // [0:13] is the sub-list for field type_name
}

func init() { file_proto_message_proto_init() }
func file_proto_message_proto_init() {
	if File_proto_message_proto != nil {
		return
	}
	file_proto_screen_proto_init()
	file_proto_control_proto_init()
	file_proto_auth_proto_init()
	file_proto_filetransfer_proto_init()
	file_proto_relay_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_proto_message_proto_msgTypes[0].Exporter = func(v any, i int) any {
			switch v := v.(*Message); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_proto_message_proto_msgTypes[0].OneofWrappers = []any{
		(*Message_ScreenUpdate)(nil),
		(*Message_ScreenUpdateRequest)(nil),
		(*Message_MouseEvent)(nil),
		(*Message_KeyEvent)(nil),
		(*Message_AuthRequest)(nil),
		(*Message_AuthResponse)(nil),
		(*Message_FileTransferRequest)(nil),
		(*Message_FileTransferResponse)(nil),
		(*Message_FileChunk)(nil),
		(*Message_FileTransferStatus)(nil),
		(*Message_RelayHandshake)(nil),
		(*Message_RelayMessage)(nil),
		(*Message_RelayStatus)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_proto_message_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proto_message_proto_goTypes,
		DependencyIndexes: file_proto_message_proto_depIdxs,
		MessageInfos:      file_proto_message_proto_msgTypes,
	}.Build()
	File_proto_message_proto = out.File
	file_proto_message_proto_rawDesc = nil
	file_proto_message_proto_goTypes = nil
	file_proto_message_proto_depIdxs = nil
}


========================================


File: internal/protocol/relay.pb.go
----------------------------------------
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.34.2
// 	protoc        v5.28.0--rc2
// source: proto/relay.proto

package protocol

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type RelayStatus_Status int32

const (
	RelayStatus_CONNECTED    RelayStatus_Status = 0
	RelayStatus_DISCONNECTED RelayStatus_Status = 1
	RelayStatus_ERROR        RelayStatus_Status = 2
)

// Enum value maps for RelayStatus_Status.
var (
	RelayStatus_Status_name = map[int32]string{
		0: "CONNECTED",
		1: "DISCONNECTED",
		2: "ERROR",
	}
	RelayStatus_Status_value = map[string]int32{
		"CONNECTED":    0,
		"DISCONNECTED": 1,
		"ERROR":        2,
	}
)

func (x RelayStatus_Status) Enum() *RelayStatus_Status {
	p := new(RelayStatus_Status)
	*p = x
	return p
}

func (x RelayStatus_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RelayStatus_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_relay_proto_enumTypes[0].Descriptor()
}

func (RelayStatus_Status) Type() protoreflect.EnumType {
	return &file_proto_relay_proto_enumTypes[0]
}

func (x RelayStatus_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RelayStatus_Status.Descriptor instead.
func (RelayStatus_Status) EnumDescriptor() ([]byte, []int) {
	return file_proto_relay_proto_rawDescGZIP(), []int{2, 0}
}

type RelayHandshake struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ClientId  string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	SessionId string `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
}

func (x *RelayHandshake) Reset() {
	*x = RelayHandshake{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proto_relay_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RelayHandshake) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelayHandshake) ProtoMessage() {}

func (x *RelayHandshake) ProtoReflect() protoreflect.Message {
	mi := &file_proto_relay_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelayHandshake.ProtoReflect.Descriptor instead.
func (*RelayHandshake) Descriptor() ([]byte, []int) {
	return file_proto_relay_proto_rawDescGZIP(), []int{0}
}

func (x *RelayHandshake) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *RelayHandshake) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

type RelayMessage struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	SenderId    string `protobuf:"bytes,1,opt,name=sender_id,json=senderId,proto3" json:"sender_id,omitempty"`
	RecipientId string `protobuf:"bytes,2,opt,name=recipient_id,json=recipientId,proto3" json:"recipient_id,omitempty"`
	Payload     []byte `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (x *RelayMessage) Reset() {
	*x = RelayMessage{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proto_relay_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RelayMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelayMessage) ProtoMessage() {}

func (x *RelayMessage) ProtoReflect() protoreflect.Message {
	mi := &file_proto_relay_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelayMessage.ProtoReflect.Descriptor instead.
func (*RelayMessage) Descriptor() ([]byte, []int) {
	return file_proto_relay_proto_rawDescGZIP(), []int{1}
}

func (x *RelayMessage) GetSenderId() string {
	if x != nil {
		return x.SenderId
	}
	return ""
}

func (x *RelayMessage) GetRecipientId() string {
	if x != nil {
		return x.RecipientId
	}
	return ""
}

func (x *RelayMessage) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

type RelayStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Status  RelayStatus_Status `protobuf:"varint,1,opt,name=status,proto3,enum=godesk.RelayStatus_Status" json:"status,omitempty"`
	Message string             `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *RelayStatus) Reset() {
	*x = RelayStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proto_relay_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RelayStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelayStatus) ProtoMessage() {}

func (x *RelayStatus) ProtoReflect() protoreflect.Message {
	mi := &file_proto_relay_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelayStatus.ProtoReflect.Descriptor instead.
func (*RelayStatus) Descriptor() ([]byte, []int) {
	return file_proto_relay_proto_rawDescGZIP(), []int{2}
}

func (x *RelayStatus) GetStatus() RelayStatus_Status {
	if x != nil {
		return x.Status
	}
	return RelayStatus_CONNECTED
}

func (x *RelayStatus) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

var File_proto_relay_proto protoreflect.FileDescriptor

var file_proto_relay_proto_rawDesc = []byte{
	0x0a, 0x11, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x72, 0x65, 0x6c, 0x61, 0x79, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x12, 0x06, 0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b, 0x22, 0x4c, 0x0a, 0x0e, 0x52,
	0x65, 0x6c, 0x61, 0x79, 0x48, 0x61, 0x6e, 0x64, 0x73, 0x68, 0x61, 0x6b, 0x65, 0x12, 0x1b, 0x0a,
	0x09, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x08, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x65,
	0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09,
	0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x22, 0x68, 0x0a, 0x0c, 0x52, 0x65, 0x6c,
	0x61, 0x79, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x73, 0x65, 0x6e,
	0x64, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x73, 0x65,
	0x6e, 0x64, 0x65, 0x72, 0x49, 0x64, 0x12, 0x21, 0x0a, 0x0c, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69,
	0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x72, 0x65,
	0x63, 0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x79,
	0x6c, 0x6f, 0x61, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x07, 0x70, 0x61, 0x79, 0x6c,
	0x6f, 0x61, 0x64, 0x22, 0x91, 0x01, 0x0a, 0x0b, 0x52, 0x65, 0x6c, 0x61, 0x79, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x12, 0x32, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b, 0x2e, 0x52, 0x65, 0x6c,
	0x61, 0x79, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52,
	0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61,
	0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
	0x65, 0x22, 0x34, 0x0a, 0x06, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x0d, 0x0a, 0x09, 0x43,
	0x4f, 0x4e, 0x4e, 0x45, 0x43, 0x54, 0x45, 0x44, 0x10, 0x00, 0x12, 0x10, 0x0a, 0x0c, 0x44, 0x49,
	0x53, 0x43, 0x4f, 0x4e, 0x4e, 0x45, 0x43, 0x54, 0x45, 0x44, 0x10, 0x01, 0x12, 0x09, 0x0a, 0x05,
	0x45, 0x52, 0x52, 0x4f, 0x52, 0x10, 0x02, 0x42, 0x2c, 0x5a, 0x2a, 0x67, 0x69, 0x74, 0x68, 0x75,
	0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x73, 0x75, 0x69, 0x66, 0x65, 0x69, 0x2f, 0x67, 0x6f, 0x64,
	0x65, 0x73, 0x6b, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x2f, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_proto_relay_proto_rawDescOnce sync.Once
	file_proto_relay_proto_rawDescData = file_proto_relay_proto_rawDesc
)

func file_proto_relay_proto_rawDescGZIP() []byte {
	file_proto_relay_proto_rawDescOnce.Do(func() {
		file_proto_relay_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_relay_proto_rawDescData)
	})
	return file_proto_relay_proto_rawDescData
}

var file_proto_relay_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_proto_relay_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_proto_relay_proto_goTypes = []any{
	(RelayStatus_Status)(0), // 0: godesk.RelayStatus.Status
	(*RelayHandshake)(nil),  // 1: godesk.RelayHandshake
	(*RelayMessage)(nil),    // 2: godesk.RelayMessage
	(*RelayStatus)(nil),     // 3: godesk.RelayStatus
}
var file_proto_relay_proto_depIdxs = []int32{
	0, // 0: godesk.RelayStatus.status:type_name -> godesk.RelayStatus.Status
	1, // [1:1] is the sub-list for method output_type
	1, // [1:1] is the sub-list for method input_type
	1, // [1:1] is the sub-list for extension type_name
	1, // [1:1] is the sub-list for extension extendee
	0, // [0:1] is the sub-list for field type_name
}

func init() { file_proto_relay_proto_init() }
func file_proto_relay_proto_init() {
	if File_proto_relay_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_proto_relay_proto_msgTypes[0].Exporter = func(v any, i int) any {
			switch v := v.(*RelayHandshake); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proto_relay_proto_msgTypes[1].Exporter = func(v any, i int) any {
			switch v := v.(*RelayMessage); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proto_relay_proto_msgTypes[2].Exporter = func(v any, i int) any {
			switch v := v.(*RelayStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_proto_relay_proto_rawDesc,
			NumEnums:      1,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proto_relay_proto_goTypes,
		DependencyIndexes: file_proto_relay_proto_depIdxs,
		EnumInfos:         file_proto_relay_proto_enumTypes,
		MessageInfos:      file_proto_relay_proto_msgTypes,
	}.Build()
	File_proto_relay_proto = out.File
	file_proto_relay_proto_rawDesc = nil
	file_proto_relay_proto_goTypes = nil
	file_proto_relay_proto_depIdxs = nil
}


========================================


File: internal/protocol/screen.pb.go
----------------------------------------
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.34.2
// 	protoc        v5.28.0--rc2
// source: proto/screen.proto

package protocol

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ScreenUpdate struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Width     int32  `protobuf:"varint,1,opt,name=width,proto3" json:"width,omitempty"`
	Height    int32  `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	ImageData []byte `protobuf:"bytes,3,opt,name=image_data,json=imageData,proto3" json:"image_data,omitempty"`
	Timestamp int64  `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (x *ScreenUpdate) Reset() {
	*x = ScreenUpdate{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proto_screen_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ScreenUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScreenUpdate) ProtoMessage() {}

func (x *ScreenUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_proto_screen_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScreenUpdate.ProtoReflect.Descriptor instead.
func (*ScreenUpdate) Descriptor() ([]byte, []int) {
	return file_proto_screen_proto_rawDescGZIP(), []int{0}
}

func (x *ScreenUpdate) GetWidth() int32 {
	if x != nil {
		return x.Width
	}
	return 0
}

func (x *ScreenUpdate) GetHeight() int32 {
	if x != nil {
		return x.Height
	}
	return 0
}

func (x *ScreenUpdate) GetImageData() []byte {
	if x != nil {
		return x.ImageData
	}
	return nil
}

func (x *ScreenUpdate) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

type ScreenUpdateRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	MaxWidth  int32 `protobuf:"varint,1,opt,name=max_width,json=maxWidth,proto3" json:"max_width,omitempty"`
	MaxHeight int32 `protobuf:"varint,2,opt,name=max_height,json=maxHeight,proto3" json:"max_height,omitempty"`
	Quality   int32 `protobuf:"varint,3,opt,name=quality,proto3" json:"quality,omitempty"` // 1-100, 影响压缩质量
}

func (x *ScreenUpdateRequest) Reset() {
	*x = ScreenUpdateRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_proto_screen_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ScreenUpdateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScreenUpdateRequest) ProtoMessage() {}

func (x *ScreenUpdateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_screen_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScreenUpdateRequest.ProtoReflect.Descriptor instead.
func (*ScreenUpdateRequest) Descriptor() ([]byte, []int) {
	return file_proto_screen_proto_rawDescGZIP(), []int{1}
}

func (x *ScreenUpdateRequest) GetMaxWidth() int32 {
	if x != nil {
		return x.MaxWidth
	}
	return 0
}

func (x *ScreenUpdateRequest) GetMaxHeight() int32 {
	if x != nil {
		return x.MaxHeight
	}
	return 0
}

func (x *ScreenUpdateRequest) GetQuality() int32 {
	if x != nil {
		return x.Quality
	}
	return 0
}

var File_proto_screen_proto protoreflect.FileDescriptor

var file_proto_screen_proto_rawDesc = []byte{
	0x0a, 0x12, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x73, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x12, 0x06, 0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b, 0x22, 0x79, 0x0a, 0x0c,
	0x53, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x12, 0x14, 0x0a, 0x05,
	0x77, 0x69, 0x64, 0x74, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x77, 0x69, 0x64,
	0x74, 0x68, 0x12, 0x16, 0x0a, 0x06, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x06, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x6d,
	0x61, 0x67, 0x65, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x09,
	0x69, 0x6d, 0x61, 0x67, 0x65, 0x44, 0x61, 0x74, 0x61, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69, 0x6d,
	0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x74, 0x69,
	0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x22, 0x6b, 0x0a, 0x13, 0x53, 0x63, 0x72, 0x65, 0x65,
	0x6e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b,
	0x0a, 0x09, 0x6d, 0x61, 0x78, 0x5f, 0x77, 0x69, 0x64, 0x74, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x08, 0x6d, 0x61, 0x78, 0x57, 0x69, 0x64, 0x74, 0x68, 0x12, 0x1d, 0x0a, 0x0a, 0x6d,
	0x61, 0x78, 0x5f, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52,
	0x09, 0x6d, 0x61, 0x78, 0x48, 0x65, 0x69, 0x67, 0x68, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x71, 0x75,
	0x61, 0x6c, 0x69, 0x74, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x07, 0x71, 0x75, 0x61,
	0x6c, 0x69, 0x74, 0x79, 0x42, 0x2c, 0x5a, 0x2a, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63,
	0x6f, 0x6d, 0x2f, 0x73, 0x75, 0x69, 0x66, 0x65, 0x69, 0x2f, 0x67, 0x6f, 0x64, 0x65, 0x73, 0x6b,
	0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
	0x6f, 0x6c, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_proto_screen_proto_rawDescOnce sync.Once
	file_proto_screen_proto_rawDescData = file_proto_screen_proto_rawDesc
)

func file_proto_screen_proto_rawDescGZIP() []byte {
	file_proto_screen_proto_rawDescOnce.Do(func() {
		file_proto_screen_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_screen_proto_rawDescData)
	})
	return file_proto_screen_proto_rawDescData
}

var file_proto_screen_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_proto_screen_proto_goTypes = []any{
	(*ScreenUpdate)(nil),        // 0: godesk.ScreenUpdate
	(*ScreenUpdateRequest)(nil), // 1: godesk.ScreenUpdateRequest
}
var file_proto_screen_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_proto_screen_proto_init() }
func file_proto_screen_proto_init() {
	if File_proto_screen_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_proto_screen_proto_msgTypes[0].Exporter = func(v any, i int) any {
			switch v := v.(*ScreenUpdate); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_proto_screen_proto_msgTypes[1].Exporter = func(v any, i int) any {
			switch v := v.(*ScreenUpdateRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_proto_screen_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proto_screen_proto_goTypes,
		DependencyIndexes: file_proto_screen_proto_depIdxs,
		MessageInfos:      file_proto_screen_proto_msgTypes,
	}.Build()
	File_proto_screen_proto = out.File
	file_proto_screen_proto_rawDesc = nil
	file_proto_screen_proto_goTypes = nil
	file_proto_screen_proto_depIdxs = nil
}


========================================


File: internal/relay/hub.go
----------------------------------------
package relay

import (
    "net"
    "sync"
)

type Hub struct {
    sessions map[string]*Session
    mu       sync.Mutex
}

func NewHub() *Hub {
    return &Hub{
        sessions: make(map[string]*Session),
    }
}

func (h *Hub) AddSession(id string, conn net.Conn) {
    h.mu.Lock()
    defer h.mu.Unlock()
    h.sessions[id] = NewSession(id, conn)
}

func (h *Hub) RemoveSession(id string) {
    h.mu.Lock()
    defer h.mu.Unlock()
    delete(h.sessions, id)
}

func (h *Hub) GetSession(id string) (*Session, bool) {
    h.mu.Lock()
    defer h.mu.Unlock()
    session, ok := h.sessions[id]
    return session, ok
}

========================================


File: internal/relay/session.go
----------------------------------------

package relay

import (
    "net"
)

type Session struct {
    ID   string
    Conn net.Conn
}

func NewSession(id string, conn net.Conn) *Session {
    return &Session{
        ID:   id,
        Conn: conn,
    }
}

========================================


File: internal/server/capture.go
----------------------------------------
package server

import (
	"bytes"
	"image/png"
	"log"
	"time"

	"github.com/kbinani/screenshot"
	"github.com/suifei/godesk/internal/protocol"
)

type Capturer struct {
	interval time.Duration
	updates  chan *protocol.ScreenUpdate
	stop     chan struct{}
}

func NewCapturer(interval time.Duration) *Capturer {
	return &Capturer{
		interval: interval,
		updates:  make(chan *protocol.ScreenUpdate),
		stop:     make(chan struct{}),
	}
}

func (c *Capturer) Start() {
	log.Println("Screen capturer started")
	ticker := time.NewTicker(c.interval)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			update, err := c.captureScreen()
			if err != nil {
				log.Printf("Error capturing screen: %v", err)
				continue
			}
			log.Printf("Screen captured: %dx%d, %d bytes",
				update.Width, update.Height, len(update.ImageData))
			c.updates <- update
		case <-c.stop:
			log.Println("Screen capturer stopped")
			return
		}
	}
}

func (c *Capturer) Stop() {
	close(c.stop)
}
func (c *Capturer) Updates() <-chan *protocol.ScreenUpdate {
	return c.updates
}

func (c *Capturer) captureScreen() (*protocol.ScreenUpdate, error) {
	bounds := screenshot.GetDisplayBounds(0)
	img, err := screenshot.CaptureRect(bounds)
	if err != nil {
		log.Printf("Error capturing screen: %v", err)
		return nil, err
	}

	var buf bytes.Buffer
	if err := png.Encode(&buf, img); err != nil {
		log.Printf("Error encoding screen: %v", err)
		return nil, err
	}

	update := &protocol.ScreenUpdate{
		Width:     int32(bounds.Dx()),
		Height:    int32(bounds.Dy()),
		ImageData: buf.Bytes(),
		Timestamp: time.Now().UnixNano(),
	}

	log.Printf("Captured screen: %dx%d", update.Width, update.Height)

	return update, nil
}

func (c *Capturer) CaptureScreen() (*protocol.ScreenUpdate, error) {
    return c.captureScreen()
}

========================================


File: internal/server/control.go
----------------------------------------
package server

========================================


File: internal/server/filetransfer.go
----------------------------------------
package server

import (
    "io"
    "os"
    "path/filepath"
)

func SendFile(conn io.Writer, filePath string) error {
    file, err := os.Open(filePath)
    if err != nil {
        return err
    }
    defer file.Close()

    _, err = io.Copy(conn, file)
    return err
}

func ReceiveFile(conn io.Reader, filePath string) error {
    os.MkdirAll(filepath.Dir(filePath), os.ModePerm)
    
    file, err := os.Create(filePath)
    if err != nil {
        return err
    }
    defer file.Close()

    _, err = io.Copy(file, conn)
    return err
}

========================================


File: internal/server/handler.go
----------------------------------------
package server

import (
	"log"
	"time"

	"github.com/suifei/godesk/internal/protocol"
	"github.com/suifei/godesk/pkg/network"
)

type ClientHandler struct {
	conn     *network.TCPConnection
	capturer *Capturer
}

func NewClientHandler(conn *network.TCPConnection) *ClientHandler {
	return &ClientHandler{
		conn:     conn,
		capturer: NewCapturer(100 * time.Millisecond), // 每100ms捕获一次屏幕
	}
}

func (h *ClientHandler) Handle() {
	log.Println("New client connected, starting handler")

	// 开始屏幕捕获
	go h.capturer.Start()
	defer h.capturer.Stop()

	// 处理来自客户端的消息
	go h.handleIncomingMessages()

	// 发送屏幕更新到客户端
	h.sendScreenUpdates()
}

func (h *ClientHandler) handleIncomingMessages() {
	log.Println("Starting to handle incoming messages")
	for {
		msg, err := h.conn.Receive()
		if err != nil {
			log.Printf("Error receiving message: %v", err)
			return
		}

		switch payload := msg.Payload.(type) {
		case *protocol.Message_MouseEvent:
			log.Printf("Received mouse event: %v", payload.MouseEvent)
		case *protocol.Message_KeyEvent:
			log.Printf("Received key event: %v", payload.KeyEvent)
		default:
			log.Printf("Received unknown message type: %T", payload)
		}
	}
}

func (h *ClientHandler) sendScreenUpdates() {
	log.Println("Starting to send screen updates")
	for update := range h.capturer.Updates() {
		log.Printf("Sending screen update: %dx%d, %d bytes",
			update.Width, update.Height, len(update.ImageData))
		msg := &protocol.Message{
			Payload: &protocol.Message_ScreenUpdate{
				ScreenUpdate: update,
			},
		}
		if err := h.conn.Send(msg); err != nil {
			log.Printf("Error sending screen update: %v", err)
			return
		}
	}
}


========================================


File: pkg/network/tcp.go
----------------------------------------
package network

import (
	"encoding/binary"
	"io"
	"net"

	"github.com/suifei/godesk/internal/protocol"
	"google.golang.org/protobuf/proto"
)

type TCPConnection struct {
	conn net.Conn
}

func NewTCPConnection(conn net.Conn) *TCPConnection {
	return &TCPConnection{conn: conn}
}

func (c *TCPConnection) Send(msg *protocol.Message) error {
	data, err := proto.Marshal(msg)
	if err != nil {
		return err
	}

	// 先发送消息长度
	lengthBuf := make([]byte, 4)
	binary.BigEndian.PutUint32(lengthBuf, uint32(len(data)))
	_, err = c.conn.Write(lengthBuf)
	if err != nil {
		return err
	}

	// 再发送消息内容
	_, err = c.conn.Write(data)
	return err
}
func (c *TCPConnection) RemoteAddr() net.Addr {
	return c.conn.RemoteAddr()
}
func (c *TCPConnection) Receive() (*protocol.Message, error) {
	// 先读取消息长度
	lengthBuf := make([]byte, 4)
	_, err := io.ReadFull(c.conn, lengthBuf)
	if err != nil {
		return nil, err
	}
	length := binary.BigEndian.Uint32(lengthBuf)

	// 再读取消息内容
	data := make([]byte, length)
	_, err = io.ReadFull(c.conn, data)
	if err != nil {
		return nil, err
	}

	// 解析消息
	msg := &protocol.Message{}
	err = proto.Unmarshal(data, msg)
	if err != nil {
		return nil, err
	}

	return msg, nil
}

func (c *TCPConnection) Close() error {
	return c.conn.Close()
}


========================================


File: pkg/network/udp.go
----------------------------------------
package network

import (
	"net"

	"github.com/suifei/godesk/internal/protocol"
	"google.golang.org/protobuf/proto"
)

type UDPConnection struct {
	conn *net.UDPConn
	addr *net.UDPAddr
}

func NewUDPConnection(conn *net.UDPConn, addr *net.UDPAddr) *UDPConnection {
	return &UDPConnection{conn: conn, addr: addr}
}

func (c *UDPConnection) Send(msg *protocol.Message) error {
	data, err := proto.Marshal(msg)
	if err != nil {
		return err
	}

	_, err = c.conn.WriteToUDP(data, c.addr)
	return err
}

func (c *UDPConnection) Receive() (*protocol.Message, error) {
	buffer := make([]byte, 65507) // UDP的最大包大小
	n, _, err := c.conn.ReadFromUDP(buffer)
	if err != nil {
		return nil, err
	}

	msg := &protocol.Message{}
	err = proto.Unmarshal(buffer[:n], msg)
	if err != nil {
		return nil, err
	}

	return msg, nil
}

func (c *UDPConnection) Close() error {
	return c.conn.Close()
}


========================================


File: pkg/utils/compression.go
----------------------------------------
package utils

========================================


File: pkg/utils/crypto.go
----------------------------------------
package utils

========================================


File: proto/auth.proto
----------------------------------------
syntax = "proto3";

package godesk;

option go_package = "github.com/suifei/godesk/internal/protocol";

message AuthRequest {
  string username = 1;
  string password = 2;  // 应该是哈希后的密码
}

message AuthResponse {
  bool success = 1;
  string token = 2;  // 如果认证成功，返回一个会话token
  string error_message = 3;  // 如果认证失败，返回错误信息
}

message TokenValidationRequest {
  string token = 1;
}

message TokenValidationResponse {
  bool valid = 1;
  string username = 2;  // 如果token有效，返回关联的用户名
}

========================================


File: proto/control.proto
----------------------------------------
syntax = "proto3";

package godesk;

option go_package = "github.com/suifei/godesk/internal/protocol";

message MouseEvent {
  enum EventType {
    MOVE = 0;
    LEFT_DOWN = 1;
    LEFT_UP = 2;
    RIGHT_DOWN = 3;
    RIGHT_UP = 4;
    MIDDLE_DOWN = 5;
    MIDDLE_UP = 6;
    SCROLL = 7;
  }
  EventType event_type = 1;
  int32 x = 2;
  int32 y = 3;
  int32 scroll_delta = 4;  // 用于滚轮事件
}

message KeyEvent {
  enum EventType {
    KEY_DOWN = 0;
    KEY_UP = 1;
  }
  EventType event_type = 1;
  int32 key_code = 2;
  bool shift = 3;
  bool ctrl = 4;
  bool alt = 5;
  bool meta = 6;  // Windows键或Command键
}

========================================


File: proto/filetransfer.proto
----------------------------------------
syntax = "proto3";

package godesk;

option go_package = "github.com/suifei/godesk/internal/protocol";

message FileTransferRequest {
  string file_name = 1;
  int64 file_size = 2;
  string destination_path = 3;
}

message FileTransferResponse {
  bool accepted = 1;
  string error_message = 2;
}

message FileChunk {
  bytes data = 1;
  int64 offset = 2;
}

message FileTransferStatus {
  enum Status {
    IN_PROGRESS = 0;
    COMPLETED = 1;
    FAILED = 2;
  }
  Status status = 1;
  int64 bytes_transferred = 2;
  string error_message = 3;
}

========================================


File: proto/message.proto
----------------------------------------
syntax = "proto3";

package godesk;

import "proto/screen.proto";
import "proto/control.proto";
import "proto/auth.proto";
import "proto/filetransfer.proto";
import "proto/relay.proto";

option go_package = "github.com/suifei/godesk/internal/protocol";

message Message {
  oneof payload {
    ScreenUpdate screen_update = 1;
    ScreenUpdateRequest screen_update_request = 2;
    MouseEvent mouse_event = 3;
    KeyEvent key_event = 4;
    AuthRequest auth_request = 5;
    AuthResponse auth_response = 6;
    FileTransferRequest file_transfer_request = 7;
    FileTransferResponse file_transfer_response = 8;
    FileChunk file_chunk = 9;
    FileTransferStatus file_transfer_status = 10;
    RelayHandshake relay_handshake = 11;
    RelayMessage relay_message = 12;
    RelayStatus relay_status = 13;
  }
}

========================================


File: proto/relay.proto
----------------------------------------
syntax = "proto3";

package godesk;

option go_package = "github.com/suifei/godesk/internal/protocol";

message RelayHandshake {
  string client_id = 1;
  string session_id = 2;
}

message RelayMessage {
  string sender_id = 1;
  string recipient_id = 2;
  bytes payload = 3;
}

message RelayStatus {
  enum Status {
    CONNECTED = 0;
    DISCONNECTED = 1;
    ERROR = 2;
  }
  Status status = 1;
  string message = 2;
}

========================================


File: proto/screen.proto
----------------------------------------
syntax = "proto3";

package godesk;

option go_package = "github.com/suifei/godesk/internal/protocol";

message ScreenUpdate {
  int32 width = 1;
  int32 height = 2;
  bytes image_data = 3;
  int64 timestamp = 4;
}

message ScreenUpdateRequest {
  int32 max_width = 1;
  int32 max_height = 2;
  int32 quality = 3;  // 1-100, 影响压缩质量
}

========================================


File: scripts/build.sh
----------------------------------------
#!/bin/bash

# 确保脚本在发生错误时退出
set -e

# 定义版本号（你可以根据需要修改）
VERSION="0.1.0"

# 定义输出目录
OUTPUT_DIR="build"

# 定义目标操作系统和架构
TARGETS=(
    "windows/amd64"
    #"linux/amd64"
    #"darwin/amd64"
)

# 创建输出目录
mkdir -p "$OUTPUT_DIR"

# 编译函数
build() {
    local module=$1
    local os=$2
    local arch=$3
    local output_name="${module}_${os}_${arch}"
    if [ "$os" = "windows" ]; then
        output_name="${output_name}.exe"
    fi
    echo "Building $module for $os/$arch..."
    GOOS=$os GOARCH=$arch go build -o "$OUTPUT_DIR/$output_name" "./cmd/$module"
}

# 为每个目标构建所有模块
for target in "${TARGETS[@]}"; do
    IFS='/' read -r -a parts <<< "$target"
    os="${parts[0]}"
    arch="${parts[1]}"
    
    build "server" "$os" "$arch"
    build "client" "$os" "$arch"
    build "relay" "$os" "$arch"
done

# 复制配置文件
echo "Copying configuration files..."
mkdir -p "$OUTPUT_DIR/configs"
cp configs/*.yaml "$OUTPUT_DIR/configs/"

# 创建版本文件
echo "$VERSION" > "$OUTPUT_DIR/version.txt"

echo "Build complete. Output is in the $OUTPUT_DIR directory."

# 显示构建输出的结构
echo "Build output structure:"
if command -v tree &> /dev/null; then
    tree "$OUTPUT_DIR"
else
    find "$OUTPUT_DIR" | sed -e "s/[^-][^\/]*\// |/g" -e "s/|\([^ ]\)/|-\1/"
fi

========================================


File: scripts/generate_proto.sh
----------------------------------------
#!/bin/bash

# 检查 protoc 是否已安装
if ! command -v protoc &> /dev/null
then
    echo "protoc could not be found. Please install Protocol Buffers compiler."
    echo "Visit https://github.com/protocolbuffers/protobuf for installation instructions."
    exit 1
fi

# 检查 protoc-gen-go 是否已安装
if ! command -v protoc-gen-go &> /dev/null
then
    echo "protoc-gen-go could not be found. Installing it now..."
    go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
    
    # 将 GOPATH/bin 添加到 PATH
    export PATH="$PATH:$(go env GOPATH)/bin"
fi

# 进入项目根目录
cd "$(dirname "$0")/.."

# 确保 internal/protocol 目录存在
mkdir -p internal/protocol

# 生成 Go 代码，并指定输出目录为 internal/protocol
protoc --go_out=. --go_opt=module=github.com/suifei/godesk \
    --go_opt=Mproto/screen.proto=github.com/suifei/godesk/internal/protocol \
    --go_opt=Mproto/control.proto=github.com/suifei/godesk/internal/protocol \
    --go_opt=Mproto/auth.proto=github.com/suifei/godesk/internal/protocol \
    --go_opt=Mproto/filetransfer.proto=github.com/suifei/godesk/internal/protocol \
    --go_opt=Mproto/relay.proto=github.com/suifei/godesk/internal/protocol \
    --go_opt=Mproto/message.proto=github.com/suifei/godesk/internal/protocol \
    proto/screen.proto \
    proto/control.proto \
    proto/auth.proto \
    proto/filetransfer.proto \
    proto/relay.proto \
    proto/message.proto

if [ $? -eq 0 ]; then
    echo "Protocol Buffers code generation completed successfully."
    echo "Generated files are in the internal/protocol directory."
else
    echo "Error occurred during Protocol Buffers code generation."
    exit 1
fi

# 移除可能在 proto 目录中生成的 .pb.go 文件
rm -f proto/*.pb.go

========================================
